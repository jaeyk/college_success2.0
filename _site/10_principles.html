<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ko" xml:lang="ko"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="김재연">

<title>대학생활 위한 필수지침 10가지 – 대학사용법 2.0</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-6bd9cfa162949bde0a231f530c97869d.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "일치 없음",
    "search-matching-documents-text": "일치된 문서",
    "search-copy-link-title": "검색 링크 복사",
    "search-hide-matches-text": "추가 검색 결과 숨기기",
    "search-more-match-text": "추가 검색결과",
    "search-more-matches-text": "추가 검색결과",
    "search-clear-button-title": "제거",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "취소",
    "search-submit-button-title": "검색",
    "search-label": "검색"
  }
}</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">대학사용법 2.0</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="검색"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="탐색 전환" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">소개</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./toc.html"> 
<span class="menu-text">목차</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="./10_principles.html" aria-current="page"> 
<span class="menu-text">대학생활 필수지침 10가지</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./license.html"> 
<span class="menu-text">라이선스</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">대학생활 위한 필수지침 10가지</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">저자</div>
    <div class="quarto-title-meta-contents">
             <p><a href="https://jaeyk.github.io">김재연</a> </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">공개</div>
    <div class="quarto-title-meta-contents">
      <p class="date">2025년 5월 12일</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<ol type="1">
<li><p><strong>대학생활을 결정짓는 것은 입시결과가 아니다 🎯</strong></p>
<p>대학 합격은 끝이 아니라 시작이다. 수석으로 입학했다고 해서 가장 영예롭게 졸업하는 것도 아니고, 추가 합격했다고 해서 초라하게 졸업하는 것도 아니다. 상위권 대학에 들어갔다고 해서 반드시 성공적인 인생을 사는 것도 아니며, 그렇지 않다고 해서 인생이 실패하는 것도 아니다. 더 나아가, 소위 명문대를 우수한 성적으로 졸업했다고 해서 자동으로 좋은 커리어가 보장되거나 인생이 순조롭게 풀리는 것도 아니다. 긴 인생에서 중요한 것은 ’현재의 위치’가 아니라, 성장 속도의 방향과 기울기다. 대학 이후의 삶을 결정짓는 것은 입시 결과나 학점이 아니라, 대학 시절 동안 갈고 닦은 삶의 태도와 부단한 노력이다.</p></li>
<li><p><strong>대학의 자원을 적극적으로 활용하라 🧭</strong></p>
<p>대학은 기회의 땅이다. 소극적으로 생활하면 학교에서 할 수 있는 것이 강의 듣고, 학점 따고, 졸업장 받는 것밖에 없다. 반면 학교가 가진 자원을 적극적으로 이용하고자 하면 훨씬 많은 기회가 있다. 내가 대학을 고용했다고 생각하자. 대학의 사용법을 스스로 발견하고 정의해나가자. 이런 태도는 이후 취직을 하든, 대학원을 가든, 유학을 가든 유용하다. 기회는 도전하고, 행동하는 사람에게만 온다.</p></li>
<li><p><strong>대학생 신분에서만 할 수 있는 일을 찾아서 하라 🧪</strong></p>
<p>사회에 나가서도 배울 수 있는 것을 학교에서 배우고, 졸업해서도 할 수 있는 일을 학생 때 하는 것은 어리석다. 기회비용이 생기기 때문이다. 학교 밖에서 배울 수 있는 것은 밖에서 배우면 되고, 나중에 할 수 있는 일은 나중에 하면 된다. 학교에서는 밖에서 배울 수 없는 강의를 신청해서 듣자. 그리고 학생이라는 사회적 위치에서만 할 수 있는 일들을 하자. 그러다보면 매 학기가 학습력과 실행력이 성장하는 기회의 시간이 된다.</p></li>
<li><p><strong>현실적인 목표를 정해서 한 단계씩 성취하라 🪜</strong></p>
<p>현실적인 목표를 설정하는 게 중요하다. 한 번에 잘할 수 있는 것은 없다. 전공이나 어학도, 소통능력도 단계별로 향상된다. 그리고 한 단계씩 넘기까지 부단한 노력이 필요하다. 너무 거창한 목표보다 조금씩 이룰 수 있는 목표를 설정하자. 한 번에 A+를 받을 수 있는 사람은 적다. 하지만 B에서 시작해서 의식적으로 노력하여 점차적으로 A+로 올라가는 것은 누구나 가능하다.</p></li>
<li><p><strong>사회에서 쓸 수 있는 학습 능력을 키워라 🧠</strong></p>
<p>대학은 ’공부’를 가르치는 곳이 아니다. ’공부하는 법’을 가르치는 곳이다. 학교에서 배운 내용은 사회에서 대부분 쓸모없다. 그 동안 사회가 이미 변해 있기 때문이다. 그러나 새로운 현상에 대해 체계적으로 학습하고 논리적으로 사고할 수 있는 능력인 ’학습 능력’을 키워두면, 사회의 어느 분야에 가더라도 적응할 수 있다. 사실 학습 능력이 향상되면 학점은 자연스럽게 따라온다. 학습 능력이 진정한 경쟁력이다.</p></li>
<li><p><strong>전공과 학교의 울타리를 벗어나라 🌍</strong></p>
<p>같은 전공을 갖고 있는 사람은 같은 방식으로 사고하기 쉽고, 같은 학교에 다니는 사람은 같은 문화에 젖어 있기 쉽다. 나와 다른 방식으로 사고하면서 다른 문화적 배경에서 자란 사람을 수용하고 존중할 줄 알아야 한다. 졸업 후 경험할 사회가 그런 곳이기 때문이다. 또한 학과 2, 3학년 선배를 넘어서 졸업한 선배, 현업에 종사하는 사람들을 많이 만나는 게 좋다. 이미 그 시기를 지나온 사람들에게서만 배울 수 있는 지혜가 있고, 그 사람들만이 줄 수 있는 기회가 있다. 우물 밖 세상은 넓다.</p></li>
<li><p><strong>다른 사람의 조언은 가려서 들어라 🧩</strong></p>
<p>인간은 편견의 동물이다. 대부분의 사람은 자기의 경험과 감성에 기초해서 조언을 해준다. 가만히 들어보면 결국 자신에게 하고 싶은 얘기를 타인에게 하는 경우가 많다. 여러 사람의 의견을 듣되, 그중에서 무엇이 옥이고 돌인지 구분하는 것은 본인의 몫이다.</p></li>
<li><p><strong>이니셔티브를 경험하라 🔥</strong></p>
<p>진짜 스펙을 만들어내는 것은 이니셔티브(initiative)다. 이니셔티브란 남보다 앞장서서 문제를 정의하고 해결하는 것을 뜻한다. 자기가 속한 공동체의 문제를 발견하고 그 문제를 해결하기 위해 꾸준히 고민하고 노력하고 학습하자. 이것이 리더십을 키우는 비결이다. 나의 문제를 넘어서 남의 문제, 우리의 문제를 고민하는 사람 그리고 그 문제를 해결하기 위해 주어진 자원을 활용할 줄 아는 사람, 자신의 부족함을 깨닫고 끊임없이 더 나은 방법을 찾는 사람. 이 사람이 진짜 인재고, 이 경험이 진짜 스펙을 만든다.</p></li>
<li><p><strong>스펙과 커리어는 같지 않다 🛤️</strong></p>
<p>이력서에 써넣을 경험이 많다고 해서 좋은 게 아니다. 그 경험의 일관성과 집중도가 중요하다. 남에게 보여주기 위한 경험에 치중하지 마라. 자기가 잘할 수 있는 일과 자신의 능력을 어디에 어떻게 써야 할지 이해하는 것이 더 실속 있다. 또한 사명감을 가지고 절실하게 추구할 수 있는 한 가지 일을 찾자. 그렇지 않으면 꽃은 화려하나 열매는 부실한 상태가 된다. 결혼을 하기 위해서는 한 이성을 택해야 하는 것처럼, 커리어를 쌓기 위해서는 내가 가야 할 ’하나의 길’을 택할 줄 알아야 한다. 나머지에 대해서는 “No”라고 말할 수 있는 성찰과 용기, 결단이 필요하다.</p></li>
<li><p><strong>태도가 인생을 좌우한다 💡</strong></p>
<p>대학생이면 이제 성인이다. 성인이라면 무엇보다 삶의 태도를 가꿀 줄 알아야 한다. 실력이 떨어지는 사람과는 일할 수 있어도 기준이 낮은 사람과는 일할 수 없다. 실력이 모자라면 배우면 되지만 기준이 낮으면 자신이 왜 배워야 하는지, 무엇이 문제인지 모르기 때문이다. 기업도, 정부도, 학교도, 이런 사람을 원하지 않는다. 나의 기준을 지키는 것이 실력이고, 다른 사람의 기준을 지키는 것이 인격이며, 모두의 기준을 지키는 것이 리더십이다.</p></li>
</ol>
<hr>
<div class="callout callout-style-default callout-tip callout-titled" title="📌 잊지 말아야 할 한 가지">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
📌 잊지 말아야 할 한 가지
</div>
</div>
<div class="callout-body-container callout-body">
<p>혹시 이 열 가지가 기억하기 어렵다면, 다음의 한 가지라도 잊지 말자.<br>
인간이라는 생물에게 존재의 목적이 있다면 그것은 더 많이 배우고 성장하고 나누는 것이다.</p>
<p>세상을 내 뜻대로 움직일 수 있다고 믿고 거창한 계획을 세워서 그대로 살려고 하지 말자. 그것은 배움과 성장을 멈추는 길이다. 그대로 된다고 해도 다른 가능성을 희생한 것이고, 그대로 되지 않으면 좌절감과 실망감이 밀려온다.</p>
<p>그 대신에 새로운 기회와 가능성에 마음을 열자. 늘 더 많이 배우려고 노력하자. 삶에서 배움을 최대화하는 것이 목표인 사람은 인생이 어떻게 펼쳐지든 절망하지 않는다. 거기서 배움의 기회를 찾기 때문이다. 일이 잘 풀리든 그렇지 않든 배워야 할 기회가 하나 더 늘어났다는 점에서는 동일하다.</p>
<p>대학졸업장이 이전 시대에 비해 고용시장에서 경쟁력이 떨어진 것은 사실이다. 그러나 대학에서 배움을 최대화하는 삶의 자세를 배운 사람은 어떠한 상황에서도 성장을 멈추지 않는다. 그리고 성장한 만큼 더 많은 가능성을 누린다.</p>
<p>20대는 아직 인생의 전반전에 불과하다. 이제 인생의 중반에 접어든 나는 이 말을 내 자신의 경험에 근거하여 할 수 있다. 게임은 아직 전반전도 끝나지 않았다. 4년의 대학시절을 다르게 살 수 있다면, 그 이후의 인생은 충분히 달라진다. 나와 다른 사람에게 끊임없이 기회를 주기로, 함께 성장하기로 선택하고 실천하는 사람은 지금 어느 곳에 있든지 더 나은 미래를 바라본다.</p>
</div>
</div>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "복사완료!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "복사완료!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>